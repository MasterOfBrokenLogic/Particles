<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Physics Comet Swipe</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<style>
html, body {margin:0; padding:0; width:100%; height:100%; background:#111; overflow:hidden;}
canvas {display:block;}
</style>
<script>
document.addEventListener('contextmenu', e => e.preventDefault());
</script>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let SPACING = 2;
let PARTICLE_SIZE = 1.5;
let DRAG = 0.90;
let EASE = 0.03;       // slow return to original position
let COLOR = 220;
let INFLUENCE_RADIUS = 4000; // squared distance
let particles = [];
let pointers = [];

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  particles = [];
  const cols = Math.floor(canvas.width / SPACING);
  const rows = Math.floor(canvas.height / SPACING);
  for(let y=0; y<rows; y++){
    for(let x=0; x<cols; x++){
      particles.push({
        x: x*SPACING + SPACING/2,
        y: y*SPACING + SPACING/2,
        ox: x*SPACING + SPACING/2,
        oy: y*SPACING + SPACING/2,
        vx: 0,
        vy: 0
      });
    }
  }
}

window.addEventListener('resize', resize);
resize();

function addPointer(x,y){
  pointers.push({x,y});
}

canvas.addEventListener('mousemove', e => addPointer(e.clientX,e.clientY));
canvas.addEventListener('touchmove', e => {
  for(let t of e.touches) addPointer(t.clientX,t.clientY);
  e.preventDefault();
},{passive:false});

function step(){
  const w = canvas.width;
  const h = canvas.height;

  // fade for trail effect
  ctx.fillStyle = 'rgba(17,17,17,0.18)';
  ctx.fillRect(0,0,w,h);

  for(let p of particles){
    // swipe influence
    for(let pointer of pointers){
      let dx = pointer.x - p.x;
      let dy = pointer.y - p.y;
      let d = dx*dx + dy*dy;
      if(d < INFLUENCE_RADIUS){
        let f = -INFLUENCE_RADIUS/d;
        let angle = Math.atan2(dy,dx);
        p.vx += f*Math.cos(angle);
        p.vy += f*Math.sin(angle);
      }
    }
    // update position
    p.x += (p.vx *= DRAG) + (p.ox - p.x)*EASE;
    p.y += (p.vy *= DRAG) + (p.oy - p.y)*EASE;
  }

  // draw particles
  ctx.fillStyle = `rgb(${COLOR},${COLOR},${COLOR})`;
  for(let p of particles){
    ctx.fillRect(p.x,p.y,PARTICLE_SIZE,PARTICLE_SIZE);
  }

  pointers = [];
  requestAnimationFrame(step);
}

step();
</script>
</body>
</html>
